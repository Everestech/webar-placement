<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR: Solución Híbrida Confiable</title>
    
    <!-- Tailwind CSS para estilos de UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Librerías de WebAR -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.2/aframe.min.js"></script>
    
    <style>
        /* Estilos generales y UI */
        body { margin: 0; padding: 0; font-family: 'Inter', sans-serif; }
        
        a-scene {
            height: 100vh;
            width: 100vw;
        }

        /* Overlay para el botón de inicio */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        /* Mensaje de estado en la parte inferior */
        #status-message {
            z-index: 1000;
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 0.75rem;
            text-align: center;
            font-size: 0.875rem;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
        }
        
        #ar-cursor-visual {
            opacity: 0.8;
            animation: pulse 1.5s infinite alternate;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.2); }
        }
    </style>
</head>
<body class="bg-gray-900 overflow-hidden">

    <!-- 
        ============================================================
        Script: Lógica de WebXR Pura + A-Frame Render
        ============================================================
    -->
    <script>
        // Variables Globales
        let scene, reticleEl;
        let xrSession = null;
        let xrRefSpace = null;
        let xrHitTestSource = null;
        let objectCount = 0;
        let canvas = null;

        // Función de inicio llamada por el botón
        async function startAR() {
            // 1. Obtener los elementos de A-Frame y el canvas de Three.js
            scene = document.querySelector('a-scene').sceneEl;
            reticleEl = document.getElementById('ar-cursor-visual');
            canvas = scene.renderer.domElement;
            
            if (!navigator.xr) {
                document.getElementById('status-message').textContent = 'WebXR no soportado en este navegador/dispositivo.';
                return;
            }

            // 2. Intentar solicitar la sesión AR inmersiva (el método más directo)
            try {
                xrSession = await navigator.xr.requestSession('immersive-ar', { 
                    requiredFeatures: ['hit-test', 'local']
                });

                // 3. Configurar el renderizador de A-Frame para la sesión
                // Esto es crucial para que A-Frame use la cámara de la sesión AR
                scene.renderer.xr.setSession(xrSession);
                
                // 4. Configurar espacios de referencia y Hit Test
                xrRefSpace = await xrSession.requestReferenceSpace('local');
                const xrViewerSpace = await xrSession.requestReferenceSpace('viewer');
                xrHitTestSource = await xrSession.requestHitTestSource({ space: xrViewerSpace });
                
                // 5. Ocultar la UI de inicio y actualizar estado
                document.getElementById('start-overlay').style.display = 'none';
                document.getElementById('status-message').textContent = 'Escaneando superficie... Mueva el móvil lentamente.';

                // 6. Iniciar el bucle de renderizado WebXR manual (sustituyendo el de A-Frame)
                xrSession.requestAnimationFrame(onXRFrame);

                // 7. Agregar listener de click al canvas (este evento sí es confiable)
                canvas.addEventListener('click', placeObject);

                // 8. Manejar el fin de la sesión
                xrSession.addEventListener('end', onXRSessionEnd);

            } catch (e) {
                console.error('Fallo la Iniciación de WebXR AR:', e);
                document.getElementById('status-message').textContent = 'Error al iniciar AR: ' + e.message;
            }
        }

        // Bucle de renderizado y hit-test manual de WebXR
        function onXRFrame(time, frame) {
            if (!xrSession) return;

            // Solicitar el siguiente frame
            xrSession.requestAnimationFrame(onXRFrame);
            
            // Renderizar la escena con A-Frame/Three.js
            // A-Frame se encarga de actualizar la pose de la cámara automáticamente en el render.
            scene.renderer.render(scene.object3D, scene.camera.el.object3D);

            // Lógica de Hit Test
            const hitTestResults = frame.getHitTestResults(xrHitTestSource);

            if (hitTestResults.length > 0) {
                reticleEl.setAttribute('visible', true);
                document.getElementById('status-message').textContent = 'Superficie detectada (cursor verde). Toque la pantalla para colocar el objeto.';
                
                const pose = hitTestResults[0].getPose(xrRefSpace);
                
                if (pose) {
                    // Aplicar la transformación directamente al objeto 3D del retículo
                    reticleEl.object3D.matrix.fromArray(pose.transform.matrix);
                    reticleEl.object3D.matrixNeedsUpdate = true;
                }
            } else {
                reticleEl.setAttribute('visible', false);
                document.getElementById('status-message').textContent = 'Mueva el móvil para escanear y encontrar superficies...';
            }
        }

        // Función de colocación llamada por el evento 'click' del canvas
        function placeObject() {
            if (!xrSession) return;

            if (reticleEl.getAttribute('visible')) {
                const position = reticleEl.object3D.position;
                
                const newObject = document.createElement('a-entity');
                
                // Objeto de ejemplo: una caja azul giratoria
                newObject.setAttribute('geometry', 'primitive: box; height: 0.2; width: 0.2; depth: 0.2');
                newObject.setAttribute('material', 'color: #3b82f6; opacity: 0.9');
                // Colocamos el objeto justo encima del cursor
                newObject.setAttribute('position', `${position.x} ${position.y + 0.1} ${position.z}`); 
                newObject.setAttribute('animation', 'property: rotation; to: 0 360 0; loop: true; dur: 4000; easing: linear');
                
                scene.appendChild(newObject);
                objectCount++;
                document.getElementById('status-message').textContent = `¡Objeto ${objectCount} colocado! Toque para añadir más.`;
            } else {
                document.getElementById('status-message').textContent = 'No se detecta superficie para colocar. Mueva el móvil.';
            }
        }

        // Función para terminar la sesión AR
        function onXRSessionEnd() {
            xrSession = null;
            xrRefSpace = null;
            xrHitTestSource = null;
            reticleEl.setAttribute('visible', false);
            document.getElementById('start-overlay').style.display = 'flex';
            document.getElementById('status-message').textContent = 'Sesión AR terminada. Presione INICIAR AR para comenzar de nuevo.';
        }
    </script>

    <!-- 
        ============================================================
        Estructura de la Escena A-Frame
        ============================================================
    -->
    <a-scene 
        id="ar-scene"
        embedded 
        renderer="logarithmicDepthBuffer: true; antialias: true" 
        
        <!-- Deshabilitamos el UI de A-Frame para usar nuestro propio botón, tal como funciona en tu código original. -->
        vr-mode-ui="enabled: false"
        
        <!-- Requerimos AR, pero no dejamos que A-Frame lo inicie automáticamente. -->
        webxr="requiredFeatures: hit-test, local; referenceSpaceType: local; optionalFeatures: dom-overlay; requestedReferenceSpaceType: local-floor">
        
        <!-- Luces -->
        <a-entity light="type: ambient; color: #BBB; intensity: 0.5"></a-entity>
        <a-entity light="type: directional; color: #FFF; intensity: 0.8" position="-1 2 1"></a-entity>
        
        <!-- CÁMARA (Sin componentes de hit-test, solo el placeholder) -->
        <a-camera 
            id="ar-camera" 
            user-height="0" 
            position="0 0 0" 
            rotation="0 0 0">
        </a-camera>
        
        <!-- CURSOR VISUAL: Es el TARGET, posicionado manualmente por la función onXRFrame -->
        <a-entity 
            id="ar-cursor-visual"
            geometry="primitive: torus; radius: 0.05; radiusTubular: 0.005; segmentsRadial: 16; segmentsTubular: 12"
            material="color: #4ade80; shader: flat"
            rotation="90 0 0" 
            visible="false">
        </a-entity>

    </a-scene>

    <!-- 
        ============================================================
        INTERFAZ DE USUARIO (UI)
        ============================================================
    -->
    <div id="start-overlay">
        <h1 class="text-2xl font-bold text-white mb-6">Iniciar Experiencia de Realidad Aumentada</h1>
        <button 
            id="ar-button"
            onclick="startAR()"
            class="px-8 py-4 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold rounded-lg shadow-xl transition duration-200 transform hover:scale-105"
        >
            INICIAR AR
        </button>
        <p class="mt-4 text-gray-300 text-sm">Asegúrese de estar en un dispositivo móvil compatible con WebXR.</p>
    </div>

    <div id="status-message">
        Esperando inicio de AR...
    </div>

</body>
</html>
